<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DuoMatch - Tic Tac Toe</title>
    <!-- Importando Fonte Nunito (Estilo Duolingo) -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&display=swap" rel="stylesheet">
    <!-- Importando FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Importando Interact.js para Drag & Drop com F√≠sica -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <!-- Importando Confetti para vit√≥ria -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
        :root {
            --duo-green: #58cc02;
            --duo-green-dark: #46a302;
            --duo-blue: #1cb0f6;
            --duo-blue-dark: #1899d6;
            --duo-red: #ff4b4b;
            --duo-red-dark: #ea2b2b;
            --duo-gray: #e5e5e5;
            --duo-gray-dark: #cecece;
            --duo-orange: #ff9600;
            --text-color: #4b4b4b;
            --bg-color: #f7f7f7;
            --card-bg: #ffffff;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            padding: 15px 20px;
            background: white;
            border-bottom: 2px solid var(--duo-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            z-index: 10;
        }

        .header-left, .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .turn-indicator {
            font-weight: 800;
            font-size: 1.2rem;
            padding: 8px 16px;
            border-radius: 12px;
            color: white;
            background-color: var(--duo-gray);
            transition: all 0.3s;
        }

        .turn-indicator.player-turn {
            background-color: var(--duo-green);
        }

        .turn-indicator.cpu-turn {
            background-color: var(--duo-red);
        }

        /* --- Game Layout --- */
        #game-layout {
            display: flex;
            flex: 1;
            height: 100%;
            padding: 20px;
            gap: 30px;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* √Årea do Tabuleiro (Esquerda/Centro) */
        #board-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
            max-width: 500px; /* Tamanho do tabuleiro */
            aspect-ratio: 1/1;
        }

        .board-cell {
            background-color: var(--card-bg);
            border: 2px solid var(--duo-gray);
            border-bottom: 5px solid var(--duo-gray);
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-color);
            position: relative;
            transition: all 0.2s;
        }

        /* Estilos de C√©lula Ocupada */
        .board-cell.taken-player {
            background-color: #d7ffb8; /* Light Green */
            border-color: var(--duo-green);
            border-bottom-color: var(--duo-green-dark);
            color: var(--duo-green-dark);
        }

        .board-cell.taken-cpu {
            background-color: #ffdfe0; /* Light Red */
            border-color: var(--duo-red);
            border-bottom-color: var(--duo-red-dark);
            color: var(--duo-red-dark);
        }

        /* √çcone de marca√ß√£o (X ou O) */
        .mark-icon {
            position: absolute;
            font-size: 4rem;
            opacity: 0;
            transform: scale(0);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 5;
        }

        .taken-player .mark-icon {
            opacity: 0.8;
            transform: scale(1);
            color: var(--duo-green);
        }

        .taken-cpu .mark-icon {
            opacity: 0.8;
            transform: scale(1);
            color: var(--duo-red);
        }

        /* √Årea das Pe√ßas (Direita) */
        #pieces-pool {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 160px;
            height: 100%;
            max-height: 500px;
            overflow-y: auto;
            padding: 5px;
            /* Scrollbar bonita */
            scrollbar-width: thin;
            scrollbar-color: var(--duo-gray-dark) transparent;
        }

        .draggable-card {
            background: white;
            border: 2px solid var(--duo-gray);
            border-bottom: 4px solid var(--duo-gray);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-color);
            cursor: grab;
            touch-action: none;
            position: relative;
            flex-shrink: 0;
            transition: transform 0.1s, box-shadow 0.1s;
            z-index: 20; /* Fica acima do tabuleiro ao arrastar */
        }

        .draggable-card:active {
            cursor: grabbing;
            transform: translateY(2px);
            border-bottom-width: 2px;
        }

        .draggable-card.is-dragging {
            z-index: 9999 !important; /* For√ßa ficar no topo */
            opacity: 0.9;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            border-color: var(--duo-blue);
        }

        .draggable-card.hidden {
            display: none;
        }

        /* Feedback visual no drag */
        .drop-active {
            border-color: var(--duo-blue);
            background-color: #f0faff;
            border-style: dashed;
        }

        /* --- Overlay --- */
        #overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .modal {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .btn {
            background-color: var(--duo-blue);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: 800;
            border-radius: 12px;
            border-bottom: 5px solid var(--duo-blue-dark);
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
        }

        .btn:active {
            border-bottom-width: 0;
            transform: translateY(5px);
        }

        /* Responsividade Mobile */
        @media (max-width: 768px) {
            #game-layout {
                flex-direction: column;
                padding: 10px;
            }

            #board-container {
                max-width: 100%;
                max-height: 55vh; /* Limita altura */
            }

            #pieces-pool {
                flex-direction: row;
                width: 100%;
                height: auto;
                max-height: 100px;
                overflow-x: auto;
                overflow-y: hidden;
            }

            .draggable-card {
                min-width: 80px;
                height: 70px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <i class="fa-solid fa-shapes" style="color: var(--duo-green); font-size: 1.5rem;"></i>
            <span style="font-weight:800; color:var(--duo-green);">Tic-Tac-Kana</span>
        </div>
        <div class="header-right">
            <div id="turn-display" class="turn-indicator player-turn">
                Sua Vez
            </div>
        </div>
    </header>

    <div id="game-layout">
        <!-- Tabuleiro -->
        <div id="board-container">
            <!-- C√©lulas geradas via JS -->
        </div>

        <!-- Pilha de Cartas -->
        <div id="pieces-pool">
            <!-- Cartas geradas via JS -->
        </div>
    </div>

    <!-- Modal de Fim de Jogo -->
    <div id="overlay">
        <div class="modal">
            <h2 id="modal-title" style="margin:0 0 10px 0; font-size: 2rem;">Fim de Jogo</h2>
            <p id="modal-msg" style="font-size: 1.2rem; color: #777;">Resultado</p>
            <button class="btn" onclick="initGame()">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // --- Dados (Kanas Simples para caber no grid) ---
        const kanaData = [
            { id: 'a', kana: '„ÅÇ', romaji: 'a' },
            { id: 'i', kana: '„ÅÑ', romaji: 'i' },
            { id: 'u', kana: '„ÅÜ', romaji: 'u' },
            { id: 'e', kana: '„Åà', romaji: 'e' },
            { id: 'o', kana: '„Åä', romaji: 'o' },
            { id: 'ka', kana: '„Åã', romaji: 'ka' },
            { id: 'ki', kana: '„Åç', romaji: 'ki' },
            { id: 'ku', kana: '„Åè', romaji: 'ku' },
            { id: 'ke', kana: '„Åë', romaji: 'ke' },
            { id: 'ko', kana: '„Åì', romaji: 'ko' },
            { id: 'sa', kana: '„Åï', romaji: 'sa' },
            { id: 'shi', kana: '„Åó', romaji: 'shi' },
            { id: 'su', kana: '„Åô', romaji: 'su' },
            { id: 'se', kana: '„Åõ', romaji: 'se' },
            { id: 'so', kana: '„Åù', romaji: 'so' }
        ];

        // --- Estado do Jogo ---
        let boardState = Array(9).fill(null); // null, 'player', 'cpu'
        let cellContents = Array(9).fill(null); // Dados da palavra em cada c√©lula
        let isPlayerTurn = true;
        let gameActive = true;

        // Elementos DOM
        const boardContainer = document.getElementById('board-container');
        const piecesPool = document.getElementById('pieces-pool');
        const turnDisplay = document.getElementById('turn-display');
        const overlay = document.getElementById('overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');

        // --- Inicializa√ß√£o ---
        function initGame() {
            // Resetar Estado
            boardState = Array(9).fill(null);
            isPlayerTurn = true;
            gameActive = true;
            overlay.style.display = 'none';
            updateTurnIndicator();

            // Limpar DOM
            boardContainer.innerHTML = '';
            piecesPool.innerHTML = '';

            // Selecionar 9 palavras aleat√≥rias
            const shuffled = [...kanaData].sort(() => 0.5 - Math.random());
            const selectedWords = shuffled.slice(0, 9);
            cellContents = selectedWords;

            // Renderizar Tabuleiro (Grid) com Romaji
            selectedWords.forEach((word, index) => {
                const cell = document.createElement('div');
                cell.className = 'board-cell dropzone';
                cell.dataset.index = index;
                cell.dataset.id = word.id;
                
                // Conte√∫do da c√©lula (Romaji)
                const text = document.createElement('span');
                text.innerText = word.romaji;
                cell.appendChild(text);

                // √çcone de Marca√ß√£o (Escondido inicialmente)
                const mark = document.createElement('i');
                mark.className = 'mark-icon fa-regular'; // classe base
                cell.appendChild(mark);

                boardContainer.appendChild(cell);
            });

            // Renderizar Pe√ßas (Pool) com Kana
            const poolWords = [...selectedWords].sort(() => 0.5 - Math.random()); // Embaralhar pool
            poolWords.forEach(word => {
                const card = document.createElement('div');
                card.className = 'draggable-card draggable';
                card.dataset.id = word.id;
                card.innerText = word.kana;
                
                // Configura√ß√£o inicial de posi√ß√£o para Interact.js
                card.style.transform = 'translate(0px, 0px)';
                card.dataset.x = 0;
                card.dataset.y = 0;

                piecesPool.appendChild(card);
            });

            setupInteract();
        }

        function updateTurnIndicator() {
            if (isPlayerTurn) {
                turnDisplay.innerText = "Sua Vez";
                turnDisplay.className = "turn-indicator player-turn";
            } else {
                turnDisplay.innerText = "Vez do Computador";
                turnDisplay.className = "turn-indicator cpu-turn";
            }
        }

        // --- L√≥gica Interact.js (Drag & Drop com "Reparenting") ---
        function setupInteract() {
            interact('.draggable').draggable({
                inertia: true,
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'body', // Restringe √† tela toda, n√£o ao container pai
                        endOnly: true
                    })
                ],
                autoScroll: true,
                listeners: {
                    start(event) {
                        if (!isPlayerTurn || !gameActive) return;
                        
                        const target = event.target;
                        
                        // 1. Pegar posi√ß√£o original
                        const rect = target.getBoundingClientRect();
                        const scrollX = window.scrollX || window.pageXOffset;
                        const scrollY = window.scrollY || window.pageYOffset;

                        // 2. Criar Placeholder (fantasma) para manter o espa√ßo na lista
                        const placeholder = document.createElement('div');
                        placeholder.className = target.className; 
                        placeholder.classList.remove('draggable'); // Placeholder n√£o √© arrast√°vel
                        placeholder.style.opacity = '0'; 
                        placeholder.style.visibility = 'hidden';
                        placeholder.id = 'drag-placeholder'; 
                        
                        // Copiar dimens√µes
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.flex = '0 0 auto'; // Evita encolhimento
                        
                        target.parentNode.insertBefore(placeholder, target);

                        // 3. Mover Card para o Body (Para n√£o ser cortado pelo overflow)
                        document.body.appendChild(target);
                        
                        // 4. Posicionar Absolutamente onde estava visualmente
                        target.style.position = 'absolute';
                        target.style.left = (rect.left + scrollX) + 'px';
                        target.style.top = (rect.top + scrollY) + 'px';
                        target.style.width = rect.width + 'px';
                        target.style.height = rect.height + 'px';
                        target.style.margin = '0';
                        target.style.zIndex = '9999';
                        
                        // 5. Resetar transform (pois agora est√° posicionado via left/top)
                        target.style.transform = 'translate(0,0)';
                        target.setAttribute('data-x', 0);
                        target.setAttribute('data-y', 0);

                        target.classList.add('is-dragging');
                    },
                    move: dragMoveListener,
                    end(event) {
                        const target = event.target;
                        target.classList.remove('is-dragging');
                        
                        const placeholder = document.getElementById('drag-placeholder');

                        // Se foi dropado com sucesso (flag setada no ondrop)
                        if (target.dataset.dropped === 'true') {
                            if (placeholder) placeholder.remove();
                            // O target ser√° removido visualmente pelo handlePlayerMove
                        } else {
                            // Se N√ÉO foi dropado, voltar para o lugar
                            if (placeholder) {
                                // Recolocar no container original
                                placeholder.parentNode.insertBefore(target, placeholder);
                                placeholder.remove();
                                
                                // Limpar estilos inline (resetar ao estado original)
                                target.style.position = '';
                                target.style.left = '';
                                target.style.top = '';
                                target.style.width = '';
                                target.style.height = '';
                                target.style.margin = '';
                                target.style.zIndex = '';
                                target.style.transform = '';
                                target.setAttribute('data-x', 0);
                                target.setAttribute('data-y', 0);
                            }
                        }
                        
                        target.dataset.dropped = ''; // Limpar flag
                    }
                }
            });

            interact('.dropzone').dropzone({
                accept: '.draggable',
                overlap: 0.50,
                ondragenter: function (event) {
                    const cell = event.target;
                    const index = parseInt(cell.dataset.index);
                    if (boardState[index] === null) {
                        cell.classList.add('drop-active');
                    }
                },
                ondragleave: function (event) {
                    event.target.classList.remove('drop-active');
                },
                ondrop: function (event) {
                    if (!isPlayerTurn || !gameActive) return;

                    const card = event.relatedTarget;
                    const cell = event.target;
                    const cellIndex = parseInt(cell.dataset.index);

                    if (boardState[cellIndex] !== null) return;

                    cell.classList.remove('drop-active');

                    if (card.dataset.id === cell.dataset.id) {
                        // ACERTOU
                        card.dataset.dropped = 'true'; // Sinaliza para o 'end' que foi sucesso
                        handlePlayerMove(cellIndex, card, cell);
                    } else {
                        // ERROU
                        card.classList.add('wrong');
                        setTimeout(() => card.classList.remove('wrong'), 500);
                        // O 'end' vai rodar logo depois e devolver o card pro lugar
                    }
                }
            });
        }

        function dragMoveListener (event) {
            if (!isPlayerTurn || !gameActive) return;
            var target = event.target;
            var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
            var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

            target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        }

        // --- Mec√¢nica de Jogo ---

        function handlePlayerMove(index, cardElement, cellElement) {
            // 1. Atualizar Estado
            boardState[index] = 'player';
            
            // 2. Visual: Sumir com o card
            // Nota: Como o card agora est√° no body, isso ainda funciona visualmente
            cardElement.style.transition = 'transform 0.3s';
            cardElement.style.transform = 'scale(0)';
            
            // Remover do DOM ap√≥s anima√ß√£o
            setTimeout(() => cardElement.remove(), 300);

            // 3. Visual: Marcar tabuleiro
            markCell(cellElement, 'player');

            // 4. Verificar Vit√≥ria
            if (checkWin('player')) {
                endGame('player');
            } else if (boardState.every(cell => cell !== null)) {
                endGame('draw');
            } else {
                // 5. Passar vez
                isPlayerTurn = false;
                updateTurnIndicator();
                setTimeout(computerTurn, 1000); 
            }
        }

        function markCell(cellElement, who) {
            const mark = cellElement.querySelector('.mark-icon');
            if (who === 'player') {
                cellElement.classList.add('taken-player');
                mark.classList.add('fa-circle'); // O
            } else {
                cellElement.classList.add('taken-cpu');
                mark.classList.add('fa-xmark'); // X
            }
        }

        // --- IA do Computador ---

        function computerTurn() {
            if (!gameActive) return;

            // 1. Encontrar c√©lulas dispon√≠veis
            const availableIndices = boardState
                .map((val, idx) => val === null ? idx : null)
                .filter(val => val !== null);

            if (availableIndices.length === 0) return;

            // 2. IA Simples
            let chosenIndex;
            if (boardState[4] === null) chosenIndex = 4;
            else chosenIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];

            const targetCell = boardContainer.children[chosenIndex];
            const targetId = targetCell.dataset.id;

            // 3. Encontrar o card correspondente na pool
            const cardToMove = Array.from(piecesPool.children).find(c => c.dataset.id === targetId && c.id !== 'drag-placeholder');

            if (cardToMove) {
                animateComputerMove(cardToMove, targetCell, chosenIndex);
            }
        }

        function animateComputerMove(card, targetCell, cellIndex) {
            // 1. Obter coordenadas iniciais e finais
            const cardRect = card.getBoundingClientRect();
            const cellRect = targetCell.getBoundingClientRect();

            // 2. Criar Placeholder para n√£o quebrar o layout da lista
            const placeholder = document.createElement('div');
            placeholder.style.width = cardRect.width + 'px';
            placeholder.style.height = cardRect.height + 'px';
            placeholder.style.flex = '0 0 auto';
            card.parentNode.insertBefore(placeholder, card);

            // 3. Mover o card para o body para garantir que fique vis√≠vel (acima de tudo)
            document.body.appendChild(card);

            // 4. Posicionar no lugar original (usando fixed para facilitar coordenadas de tela)
            card.style.position = 'fixed';
            card.style.left = cardRect.left + 'px';
            card.style.top = cardRect.top + 'px';
            card.style.width = cardRect.width + 'px';
            card.style.height = cardRect.height + 'px';
            card.style.margin = '0';
            card.style.zIndex = '9999';
            card.style.transform = 'translate(0, 0)'; // Resetar transform anterior
            
            // Adicionar classe para efeito visual de "arrastando" (sombra, etc)
            card.classList.add('is-dragging'); 

            // For√ßar reflow
            void card.offsetWidth;

            // 5. Calcular destino (centralizar na c√©lula)
            const destX = cellRect.left + (cellRect.width - cardRect.width) / 2;
            const destY = cellRect.top + (cellRect.height - cardRect.height) / 2;

            // 6. Animar
            card.style.transition = 'all 1s cubic-bezier(0.2, 1, 0.3, 1)'; // Movimento suave e vis√≠vel
            card.style.left = destX + 'px';
            card.style.top = destY + 'px';

            // 7. Finalizar jogada ap√≥s anima√ß√£o
            setTimeout(() => {
                // Atualizar estado
                boardState[cellIndex] = 'cpu';
                markCell(targetCell, 'cpu');
                
                // Remover card e placeholder
                card.remove();
                placeholder.remove();

                // Verificar condi√ß√µes de fim de jogo
                if (checkWin('cpu')) {
                    endGame('cpu');
                } else if (boardState.every(cell => cell !== null)) {
                    endGame('draw');
                } else {
                    isPlayerTurn = true;
                    updateTurnIndicator();
                }
            }, 1000); // Tempo igual ao da transi√ß√£o
        }

        // --- Verifica√ß√£o de Vit√≥ria ---
        function checkWin(player) {
            const wins = [
                [0,1,2], [3,4,5], [6,7,8], // Linhas
                [0,3,6], [1,4,7], [2,5,8], // Colunas
                [0,4,8], [2,4,6]           // Diagonais
            ];

            return wins.some(combo => {
                return combo.every(index => boardState[index] === player);
            });
        }

        function endGame(winner) {
            gameActive = false;
            overlay.style.display = 'flex';
            
            if (winner === 'player') {
                modalTitle.innerText = "Voc√™ Venceu! üéâ";
                modalTitle.style.color = "var(--duo-green)";
                modalMsg.innerText = "Parab√©ns, seu japon√™s est√° afiado!";
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            } else if (winner === 'cpu') {
                modalTitle.innerText = "Computador Venceu ü§ñ";
                modalTitle.style.color = "var(--duo-red)";
                modalMsg.innerText = "Tente novamente!";
            } else {
                modalTitle.innerText = "Empate! ü§ù";
                modalTitle.style.color = "var(--duo-blue)";
                modalMsg.innerText = "Foi um jogo acirrado.";
            }
        }

        // Iniciar Jogo
        window.onload = initGame;

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chamada Real com IA</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* =========================================
           VARIÁVEIS DE COR E RESET
           ========================================= */
        :root {
            --bg-color: #ffffff;
            --text-color: #4b4b4b;
            --ai-color: #58cc02;
            --ai-bg: #cefc9b;
            --user-color: #1cb0f6;
            --user-bg: #ddf4ff;
            --danger-color: #ff4b4b;
            --danger-shadow: #ea2b2b;
            --btn-shadow-offset: 6px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Nunito', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #f0f2f5;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* =========================================
           LAYOUT PRINCIPAL E OVERLAY
           ========================================= */
        .app-container {
            width: 100%;
            max-width: 480px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            position: relative;
        }

        @media (min-width: 481px) {
            .app-container {
                height: 85vh;
                border-radius: 24px;
                border: 2px solid #e5e5e5;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1);
                overflow: hidden;
            }
        }

        /* Overlay de Início (Necessário para permissões) */
        .start-overlay {
            position: absolute;
            inset: 0;
            background-color: white;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            text-align: center;
            transition: opacity 0.4s ease;
        }

        .start-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .start-btn {
            background-color: var(--ai-color);
            color: white;
            font-size: 18px;
            font-weight: 800;
            padding: 16px 32px;
            border: none;
            border-radius: 16px;
            box-shadow: 0 6px 0 #58a700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 30px;
        }

        .start-btn:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 transparent;
        }

        /* Cabeçalho */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%);
            z-index: 10;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: #afafaf;
            cursor: pointer;
            font-weight: bold;
        }

        .call-status {
            font-weight: 700;
            color: var(--ai-color);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .call-status.error { color: var(--danger-color); }

        .live-dot {
            width: 8px;
            height: 8px;
            background-color: currentColor;
            border-radius: 50%;
            animation: blink 1.5s infinite;
        }

        /* =========================================
           ÁREA DA CHAMADA E AVATAR ANIMADO
           ========================================= */
        .call-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #f7f7f7;
            overflow: hidden;
        }

        .ai-avatar-wrapper {
            position: relative;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background-color: #e5e5e5; /* Cor de fundo padrão */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 0 rgba(0,0,0,0.1);
            z-index: 2;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        /* Div que irá receber as classes com as imagens de fundo */
        .ai-avatar {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            transition: background-image 0.08s ease-in-out; /* Mais rápida para não parecer presa */
        }

        /* Classes de animação da boca de acordo com os links fornecidos */
        .mouth-fechada {
            background-image: url('https://i.postimg.cc/cCbfsMf0/screeshot3.jpg');
        }
        .mouth-meio {
            background-image: url('https://i.postimg.cc/cHDnmM98/screeshot4.jpg');
        }
        .mouth-quase {
            background-image: url('https://i.postimg.cc/5ND8Tgxw/screeshot2.jpg');
        }
        .mouth-aberta {
            background-image: url('https://i.postimg.cc/MTsQDbPr/screeshot1.jpg');
        }

        .ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: var(--ai-color);
            opacity: 0;
            z-index: 1;
            pointer-events: none;
        }

        .speaking-ai .ai-avatar-wrapper {
            transform: scale(1.05);
            box-shadow: 0 0 0 6px rgba(88, 204, 2, 0.3);
        }
        .speaking-ai .ring:nth-child(1) { animation: pulse 1.5s infinite; }
        .speaking-ai .ring:nth-child(2) { animation: pulse 1.5s infinite 0.5s; }

        .speaking-user .ai-avatar-wrapper {
            box-shadow: 0 0 0 4px rgba(28, 176, 246, 0.3);
        }

        /* =========================================
           LEGENDAS
           ========================================= */
        .captions-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: flex-end;
            pointer-events: none;
            z-index: 5;
            min-height: 100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .show-captions .captions-overlay { opacity: 1; }

        .caption-line {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            line-height: 1.4;
            animation: slideUp 0.3s ease;
            backdrop-filter: blur(4px);
            width: fit-content;
        }

        .caption-speaker.ai { color: #cefc9b; font-weight: 800; margin-right: 4px; }
        .caption-speaker.user { color: #ddf4ff; font-weight: 800; margin-right: 4px; }

        /* =========================================
           RODAPÉ
           ========================================= */
        footer {
            padding: 25px 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            background-color: white;
            border-top: 2px solid #e5e5e5;
            z-index: 10;
        }

        .control-btn {
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.1s ease;
        }

        .sec-btn {
            width: 56px;
            height: 56px;
            background-color: white;
            border: 2px solid #e5e5e5;
            box-shadow: 0 4px 0 #e5e5e5;
            color: #afafaf;
        }
        .sec-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 transparent;
        }
        .sec-btn.active {
            color: var(--user-color);
            border-color: var(--user-bg);
            background-color: var(--user-bg);
        }

        .end-call {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            box-shadow: 0 4px 0 var(--danger-shadow);
            color: white;
        }

        .mic-btn {
            width: 64px;
            height: 64px;
            background-color: white;
            border: 2px solid #e5e5e5;
            box-shadow: 0 4px 0 #e5e5e5;
            color: var(--text-color);
        }

        .mic-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 transparent;
        }

        .mic-btn.muted {
            background-color: #f7f7f7;
            color: #ff4b4b;
            border-color: #e5e5e5;
        }

        /* Animações e Ícones */
        @keyframes pulse {
            0% { width: 160px; height: 160px; opacity: 0.4; }
            100% { width: 300px; height: 300px; opacity: 0; }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .icon-sm { width: 24px; height: 24px; fill: currentColor; }
        .icon-md { width: 28px; height: 28px; fill: currentColor; }
        .mic-off-path { display: none; }
        .muted .mic-off-path { display: block; }
        .muted .mic-on-path { display: none; }

    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        
        <!-- Tela de Inicialização -->
        <div class="start-overlay" id="start-overlay">
            <h2 style="color: #4b4b4b; margin-bottom: 10px;">Pronto para praticar?</h2>
            <p style="color: #afafaf; font-size: 15px;">A IA ouvirá a sua voz através do microfone.</p>
            <button class="start-btn" id="start-btn">Iniciar Chamada</button>
        </div>

        <header>
            <button class="close-btn" aria-label="Fechar" onclick="location.reload()">✕</button>
            <div class="call-status" id="call-status">
                <div class="live-dot"></div>
                <span>A conectar...</span>
            </div>
            <div style="width: 24px;"></div>
        </header>

        <main class="call-area show-captions" id="call-area">
            <div class="ring"></div>
            <div class="ring"></div>
            <div class="ai-avatar-wrapper">
                <!-- A div onde ocorre a magia da troca de imagens CSS -->
                <div id="ai-avatar-img" class="ai-avatar mouth-fechada"></div>
            </div>

            <div class="captions-overlay" id="captions-overlay"></div>
        </main>

        <footer>
            <button class="control-btn sec-btn active" id="captions-btn">
                <svg class="icon-sm" viewBox="0 0 24 24">
                    <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                </svg>
            </button>

            <button class="control-btn mic-btn" id="mic-btn">
                <svg class="icon-md" viewBox="0 0 24 24">
                    <g class="mic-on-path">
                        <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                        <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                    </g>
                    <g class="mic-off-path">
                        <path d="M19 11v-1c0-.79-.19-1.53-.53-2.2l1.49-1.49C20.61 7.6 21 9.24 21 11v1h-2zm-2.02-4.02c.01-.32.02-.65.02-.98V5c0-1.66-1.34-3-3-3S11 3.34 11 5v.02l5.98 5.96zM4.27 3L3 4.27l6 6V11c0 1.66 1.34 3 3 3 .32 0 .65-.01.98-.02l2.84 2.84C14.76 17.59 13.4 18 12 18c-3.31 0-6-2.69-6-6H4c0 4.08 3.05 7.44 7 7.93V22h2v-2.07c1.38-.16 2.66-.68 3.79-1.44l2.94 2.94L21 20.73 4.27 3z"/>
                    </g>
                </svg>
            </button>

            <button class="control-btn sec-btn end-call" onclick="location.reload()">
                <svg class="icon-sm" viewBox="0 0 24 24" style="transform: rotate(135deg);">
                    <path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"/>
                </svg>
            </button>
        </footer>
    </div>

    <!-- Elemento de áudio fixo e oculto para o contexto de áudio ser ligado a ele -->
    <audio id="ai-audio-player" style="display: none;"></audio>

    <script>
        // Configurações e Estado
        const apiKey = ""; // Chave injetada automaticamente pelo ambiente
        let isMuted = false;
        let isAITalking = false;
        let captionsVisible = true;
        let conversationHistory = [];
        
        // Elementos DOM
        const callArea = document.getElementById('call-area');
        const captionsOverlay = document.getElementById('captions-overlay');
        const statusText = document.querySelector('#call-status span');
        const statusContainer = document.getElementById('call-status');
        const micBtn = document.getElementById('mic-btn');
        const startOverlay = document.getElementById('start-overlay');
        const startBtn = document.getElementById('start-btn');
        const captionsBtn = document.getElementById('captions-btn');
        const aiAudioPlayer = document.getElementById('ai-audio-player');
        const aiAvatarImg = document.getElementById('ai-avatar-img');

        // =========================================
        // WEB AUDIO API (Análise de Frequências)
        // =========================================
        let audioCtx, analyser, audioSource, animationFrameId;
        let smoothedVolume = 0; // Variável para suavizar o salto de volume
        
        function initAudioContext() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                
                // Liga o reprodutor de áudio oculto ao analisador e este aos auscultadores (destino)
                audioSource = audioCtx.createMediaElementSource(aiAudioPlayer);
                audioSource.connect(analyser);
                analyser.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function analyzeVolume() {
            if (!isAITalking) {
                aiAvatarImg.className = 'ai-avatar mouth-fechada';
                return;
            }
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Determina o pico de volume bruto
            let rawMaxVolume = 0;
            for(let i = 0; i < bufferLength; i++) {
                if(dataArray[i] > rawMaxVolume) {
                    rawMaxVolume = dataArray[i];
                }
            }
            
            // AMPLIFICAÇÃO: Aumenta o ganho do volume lido em 40% para forçar expressões maiores
            rawMaxVolume = Math.min(255, rawMaxVolume * 1.4);
            
            // Suavização (50/50 - o verdadeiro meio-termo)
            smoothedVolume = smoothedVolume * 0.5 + rawMaxVolume * 0.5;
            
            // Modulador de Sílabas: Desce mais um pouco (base 0.4) para mostrar movimento, 
            // mas num ritmo confortável (divisor 120)
            const syllableModulator = 0.4 + 0.6 * Math.abs(Math.sin(Date.now() / 200));
            
            // Multiplica o volume suavizado pelo modulador
            const effectiveVolume = smoothedVolume * syllableModulator;
            
            if (aiAvatarImg.classList.contains('mouth-aberta'))
            {
                // aiAvatarImg.className = 'ai-avatar mouth-fechada';
                // animationFrameId = requestAnimationFrame(analyzeVolume);
                // return;
            }
            // Limites ajustados para a nova amplificação
            console.log(effectiveVolume)
            if (effectiveVolume > 210) {
                aiAvatarImg.className = 'ai-avatar mouth-aberta';
            } else if (effectiveVolume > 140) {
                aiAvatarImg.className = 'ai-avatar mouth-meio';
            } else {
                aiAvatarImg.className = 'ai-avatar mouth-fechada';
            }

            // Continua o loop na velocidade do frame
            animationFrameId = requestAnimationFrame(analyzeVolume);
        }

        // =========================================
        // RECONHECIMENTO DE VOZ (SpeechRecognition)
        // =========================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'pt-BR';
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onstart = () => {
                if (!isAITalking && !isMuted) {
                    statusText.textContent = "A escutar...";
                    statusContainer.classList.remove('error');
                }
            };

            recognition.onresult = async (event) => {
                const transcript = event.results[0][0].transcript;
                if (transcript.trim().length > 0) {
                    handleUserSpeech(transcript);
                }
            };

            recognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.error("Erro no reconhecimento:", event.error);
                }
            };

            recognition.onend = () => {
                if (!isMuted && !isAITalking) {
                    try { recognition.start(); } catch (e) {}
                }
            };
        } else {
            statusText.textContent = "Reconhecimento de voz não suportado no navegador.";
            statusContainer.classList.add('error');
            micBtn.disabled = true;
        }

        // =========================================
        // UTILITÁRIOS DA UI
        // =========================================
        captionsBtn.addEventListener('click', () => {
            captionsVisible = !captionsVisible;
            callArea.classList.toggle('show-captions', captionsVisible);
            captionsBtn.classList.toggle('active', captionsVisible);
        });

        micBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            micBtn.classList.toggle('muted', isMuted);
            
            if (isMuted) {
                statusText.textContent = "Microfone desativado";
                if(recognition) recognition.stop();
            } else {
                statusText.textContent = "A escutar...";
                if(recognition && !isAITalking) {
                    try { recognition.start(); } catch(e){}
                }
            }
        });

        function showCaption(speaker, text, duration = null) {
            const line = document.createElement('div');
            line.className = 'caption-line';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = `caption-speaker ${speaker}`;
            nameSpan.textContent = speaker === 'ai' ? 'Duo:' : 'Você:';
            
            line.appendChild(nameSpan);
            line.appendChild(document.createTextNode(' ' + text));
            captionsOverlay.appendChild(line);

            if (captionsOverlay.children.length > 3) {
                captionsOverlay.removeChild(captionsOverlay.firstChild);
            }

            if (duration) {
                setTimeout(() => {
                    line.style.opacity = '0';
                    line.style.transition = 'opacity 0.5s';
                    setTimeout(() => { if (captionsOverlay.contains(line)) line.remove(); }, 500);
                }, duration);
            }
            return line;
        }

        // =========================================
        // LÓGICA DE API GEMINI (COM RETRY)
        // =========================================
        async function fetchWithRetry(url, options, maxRetries = 5) {
            const delays = [1000, 2000, 4000, 8000, 16000];
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(res => setTimeout(res, delays[i]));
                }
            }
        }

        // 1. Gera Texto usando Gemini Flash
        async function generateAIText(userText) {
            conversationHistory.push({ role: "user", parts: [{ text: userText }] });
            
            const payload = {
                contents: conversationHistory,
                systemInstruction: { 
                    parts: [{ text: "Você é um professor de espanhol amigável e animado chamado Duo, no estilo do Duolingo. Responda em espanhol. Suas respostas devem ser curtas (1 a 3 frases no máximo), naturais e conversacionais, como em uma chamada de voz real com um aluno. Dê incentivos." }] 
                }
            };

            const aiText = "Você é um professor de espanhol amigável e animado chamado Duo, no estilo do Duolingo. Responda em espanhol. Suas respostas devem ser curtas (1 a 3 frases no máximo), naturais e conversacionais, como em uma chamada de voz real com um aluno. Dê incentivos.";
            conversationHistory.push({ role: "model", parts: [{ text: aiText }] });
            return aiText;
        }

        // 2. Converte PCM16 Base64 para WAV (Para o TTS do Gemini)
        function pcmToWav(base64Data, sampleRate) {
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const wavBuffer = new ArrayBuffer(44 + bytes.length);
            const view = new DataView(wavBuffer);
            
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + bytes.length, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, bytes.length, true);
            new Uint8Array(wavBuffer, 44).set(bytes);

            return new Blob([wavBuffer], { type: 'audio/wav' });
        }

        // 3. Gera Áudio (TTS) e Inicia o Analisador de Frequências (Mouth Anim)
        async function playTTS(text) {
            const payload = {
                contents: [{ parts: [{ text: `Say cheerfully: ${text}` }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Aoede" } } }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            const result = await fetchWithRetry(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const inlineData = result.candidates[0].content.parts[0].inlineData;
            const sampleRate = parseInt(inlineData.mimeType.match(/rate=(\d+)/)?.[1] || 24000);
            
            const wavBlob = pcmToWav(inlineData.data, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            
            return new Promise((resolve) => {
                aiAudioPlayer.src = audioUrl;
                
                aiAudioPlayer.onplay = () => {
                    callArea.classList.add('speaking-ai');
                    statusText.textContent = "A IA está a falar...";
                    // Inicia a animação da boca baseada no analisador de volume
                    analyzeVolume();
                };
                
                aiAudioPlayer.onended = () => {
                    callArea.classList.remove('speaking-ai');
                    // Retorna à pose fechada e cancela o loop
                    aiAvatarImg.className = 'ai-avatar mouth-fechada';
                    if(animationFrameId) cancelAnimationFrame(animationFrameId);
                    resolve();
                };
                
                aiAudioPlayer.play();
            });
        }

        // =========================================
        // FLUXO PRINCIPAL DA CONVERSA
        // =========================================
        async function handleUserSpeech(transcript) {
            if (isAITalking) return;
            
            if(recognition) recognition.stop();
            isAITalking = true;
            
            showCaption('user', transcript, 5000);
            statusText.textContent = "A IA está a pensar...";

            try {
                const aiResponseText = await generateAIText(transcript);
                const aiCaptionLine = showCaption('ai', aiResponseText);

                await playTTS(aiResponseText);
                
                setTimeout(() => { aiCaptionLine.remove(); }, 2000);

            } catch (err) {
                console.error("Erro no fluxo do Gemini:", err);
                statusText.textContent = "Erro na ligação.";
                statusContainer.classList.add('error');
            } finally {
                isAITalking = false;
                if (!isMuted && recognition) {
                    statusText.textContent = "A escutar...";
                    try { recognition.start(); } catch(e){}
                } else if (isMuted) {
                    statusText.textContent = "Microfone desativado";
                }
            }
        }

        // =========================================
        // INÍCIO DA APLICAÇÃO (Permissões Web Audio)
        // =========================================
        startBtn.addEventListener('click', async () => {
            // Importante ligar o AudioContext após um clique para as políticas do navegador
            initAudioContext();
            
            startOverlay.classList.add('hidden');
            statusText.textContent = "A estabelecer ligação...";
            isAITalking = true;
            
            try {
                const aiResponseText = await generateAIText("(O aluno acabou de entrar na chamada. Diga '¡Hola!' e pergunte como ele está de forma animada. Seja muito breve.)");
                const aiCaptionLine = showCaption('ai', aiResponseText);
                await playTTS(aiResponseText);
                setTimeout(() => { aiCaptionLine.remove(); }, 2000);
            } catch(e) {
                console.error(e);
            }
            
            isAITalking = false;
            
            if (recognition && !isMuted) {
                statusText.textContent = "A escutar...";
                try { recognition.start(); } catch(e){}
            }
        });

    </script>
</body>
</html>